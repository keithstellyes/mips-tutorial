<!--
  Standard build for mips-tutorial

  This is a tutorial by Keith Stellyes. Markdown source for it can be found
  here: https://github.com/keithstellyes/mips-tutorial using that source,
  one can build it themselves, or may use something like pandoc to build
  a PDF. The content of this tutorial is under the following license:

  Creative Commons Attribution 4.0 International License
  https://creativecommons.org/licenses/by/4.0/legalcode

  To contact the author regarding license violation (such as if this content is
  hosted without attribution to me, or other miscelanneous questions, don't
  hesitate to e-mail me at contact@keithstellyes.com

  -->

<div class="toc">
<ul>
<li><a href="#introduction">INTRODUCTION</a><ul>
<li><a href="#who-is-this-for-and-who-is-it-not-for">Who is this for (and who is it not for?)</a></li>
<li><a href="#why-learn-assembly">Why learn assembly?</a></li>
<li><a href="#is-it-difficult">Is it difficult?</a></li>
<li><a href="#why-mips-assembly-and-not-another-architecture">Why MIPS Assembly and not another architecture?</a></li>
<li><a href="#what-do-i-need-to-already-know">What do I need to already know?</a></li>
<li><a href="#a-few-notes-before-you-start">A few notes before you start</a></li>
<li><a href="#set-up-and-usage">Set-up and usage</a></li>
<li><a href="#resources">Resources</a></li>
<li><a href="#contributing">Contributing</a></li>
</ul>
</li>
<li><a href="#part-1-hello-world">Part 1: Hello, World!</a><ul>
<li><a href="#taking-the-plunge">Taking the plunge</a></li>
<li><a href="#explanation-line-by-line">Explanation line-by-line</a></li>
<li><a href="#source">Source</a></li>
<li><a href="#wrap-up">Wrap-up</a></li>
</ul>
</li>
<li><a href="#part-2-ab">Part 2: A+B</a><ul>
<li><a href="#walking-through-it">Walking through it.</a></li>
<li><a href="#source_1">Source</a></li>
<li><a href="#wrap-up_1">Wrap-up</a></li>
</ul>
</li>
<li><a href="#part-3-echo">Part 3: Echo</a><ul>
<li><a href="#walking-through-it_1">Walking through it.</a></li>
<li><a href="#source_2">Source</a></li>
<li><a href="#wrap-up_2">Wrap-up</a></li>
</ul>
</li>
<li><a href="#part-4-a-b">Part 4: A == B</a><ul>
<li><a href="#walking-through-it_2">Walking through it</a></li>
<li><a href="#source_3">Source</a></li>
<li><a href="#wrap-up_3">Wrap-up</a></li>
</ul>
</li>
<li><a href="#part-5-loop-n-times">Part 5: Loop N Times</a><ul>
<li><a href="#walking-through-it_3">Walking through it</a></li>
<li><a href="#source_4">Source</a></li>
<li><a href="#wrap-up_4">Wrap-up</a></li>
</ul>
</li>
<li><a href="#part-6-99-bottles-of-beer">Part 6: 99 Bottles of Beer</a><ul>
<li><a href="#walking-through-it_4">Walking through it</a></li>
<li><a href="#source_5">Source</a></li>
<li><a href="#wrap-up_5">Wrap-up</a></li>
</ul>
</li>
<li><a href="#part-7-guess-the-number">Part 7: Guess the Number</a><ul>
<li><a href="#walking-through-it_5">Walking through it</a></li>
<li><a href="#source_6">Source</a></li>
<li><a href="#wrap-up_6">Wrap-up</a></li>
</ul>
</li>
<li><a href="#part-8-getting-string-length">Part 8: Getting String Length</a><ul>
<li><a href="#walking-through-it_6">Walking through it</a></li>
<li><a href="#source_7">Source</a></li>
<li><a href="#wrap-up_7">Wrap-up</a></li>
</ul>
</li>
<li><a href="#licensingrightscontact">Licensing/Rights/Contact</a></li>
</ul>
</div>
<!-- Changelog -->

<p><strong>Changelog</strong></p>
<table>
<thead>
<tr>
<th>Date (PST)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>2017-12-06</td>
<td>Various revisions made in intro ; Who is this for? section</td>
</tr>
<tr>
<td>2016-11-21</td>
<td>Part 8 added</td>
</tr>
<tr>
<td>2016-11-18</td>
<td>Various edits and revisions</td>
</tr>
<tr>
<td>2016-11-17</td>
<td>Part 7 added ; minor edit (by GitHub user stayliv3)</td>
</tr>
<tr>
<td>2016-11-16</td>
<td>Various revisions and edits (1 by Dylan Holland) (1 by GitHub user stayliv3)</td>
</tr>
<tr>
<td>2016-11-13</td>
<td>Part 6 added ; Added resources section ; MIPS setup instructions added to Introduction ; Link to MIPS instruction set added in Part 3 wrap-up ; minor edits&amp;revision</td>
</tr>
<tr>
<td>2016-11-12</td>
<td>Part 5 added ;  Minor re-wording in Part 1 &amp; 4</td>
</tr>
</tbody>
</table>
<!-- Introduction -->

<h1 id="introduction">INTRODUCTION</h1>
<p>MIPS is a CPU architecture that has been used in various embedded systems
from the Game Boy Advance to the Sony PlayStation. It is a simple enough 
architecture learn and is a good stepping stone if one wants to learn assembly
for other CPU architectures, such as those found in personal computers.</p>
<p>This is a tutorial that aims to give a thorough walkthrough of usage and the
general thought process behind writing assembly.</p>
<p>The Markdown files used to write this tutorial, and the makefile are available
on GitHub, see the section Contributing.</p>
<h2 id="who-is-this-for-and-who-is-it-not-for">Who is this for (and who is it not for?)</h2>
<p>This tutorial was written as assembly can be quite intimidating however
enriching learning it can be. Sometimes it helps to learn by examples where
one is kind of walked through it and the thought process is explained step-by-step.
If you already are comfortable with other assembly architectures, then this
may not be so useful.</p>
<h2 id="why-learn-assembly">Why learn assembly?</h2>
<p>Learning assembly is a must if one hopes to get a solid understanding of how
higher-level programming languages like C, or even Java or Python eventually
translate (<em>compile</em>) to actual instructions. In many ways however, knowing
this will help you better implement algorithms as you get used to thinking at
a more basic level.</p>
<p>Also, if you ever intend to use debugging software like <code>gdb</code>, or want to
reverse-engineer software, with things like Cheat Engine to hack videogames
(Just do it in single-player please ;) ) assembly is a must-know. Of course,
don't take me too literally here, as with things like Cheat Engine or <code>gdb</code>,
you'll be using a different architecture that will be a bit more complicated
than MIPS, but not too much. This is a good starting ground.</p>
<p>If you also wanna write a compiler, or otherwise wanna work
low-level for other reasons, MIPS is a good place to get your feet wet. But,
if this applies to you, I doubt you needed an explanation.</p>
<h2 id="is-it-difficult">Is it difficult?</h2>
<p>In a fundamental sense, one can <em>theoretically</em> learn assembly easier
than other programming languages, such as Python or C++. This is because it
is the most basic level of direction. But, here in the real world, assembly is
actually much more difficult to write software in, even trivial applications
can easily become a headache in assembly.</p>
<p>There's no OOP to learn, inheritance, lambdas, or anything like that. There is
a simplicity you may learn to appreciate. Of course, you'll also gain an
appreciation of many higher-level language features ;) I promise it's fun,
though.</p>
<h2 id="why-mips-assembly-and-not-another-architecture">Why MIPS Assembly and not another architecture?</h2>
<ul>
<li>
<p>MIPS is a <em>RISC</em> architecture (Reduced Instruction Set), so learning the
basics is much simpler, and can focus on the actual programming. It is simpler
to learn than the architecture used in standard personal computers: x86-64 or even
ARM commonly used in smart phones.</p>
</li>
<li>
<p>Implementations of MIPS simulators (In particular, MARS) I've found to be
much simpler and easier to use than those for LLVM or LC3 or ARM. (Don't read
this as negativity about LLVM and LC3, those are very good projects with a lot
of smart people.)</p>
</li>
<li>
<p>Actually runs on native hardware. Unlike things like LC3.</p>
</li>
</ul>
<h2 id="what-do-i-need-to-already-know">What do I need to already know?</h2>
<p>If you know any basic programming, you should be fine, if you know C or C++
you're golden. </p>
<h2 id="a-few-notes-before-you-start">A few notes before you start</h2>
<p>You will hear both <em>registers</em> and <em>memory</em> talked about. A register is a
memory unit that is inside the CPU as opposed to <em>memory</em> that we can perform
actions directly with. For data that isn't in one of your few registers,
you must load it from memory into a registerbefore you can do things like math with it. If
this doesn't quite make sense, it should make sense as you go through this
tutorial and have a bit more context.</p>
<h2 id="set-up-and-usage">Set-up and usage</h2>
<p>I highly recommend the MARS simulator 
(<a href="http://courses.missouristate.edu/KenVollmar/mars/download.htm">available here</a>)
for running these MIPS code samples. It runs on Windows, Mac, Linux, and since
it's a Java .jar, likely also will run on *BSD too, but I can't attest to that.
Running a program involves a two step process:</p>
<ul>
<li>Assemble (F3)</li>
</ul>
<p>This will translate what you wrote to the actual machine language, and prepare
for actually running your code.</p>
<ul>
<li>Run (F5)</li>
</ul>
<p>This will run your assembled code, note you <em>must</em> assemble it first.</p>
<h2 id="resources">Resources</h2>
<ul>
<li><a href="http://www.mrc.uidaho.edu/mrc/people/jff/digital/MIPSir.html">The instruction set (James F. Frenzel @ University of Idaho)</a></li>
</ul>
<p>This is a very good general reference. MIPS is a simple enough architecture
to read all of. Useful to lookup the different branching
instructions available, math, etc.</p>
<ul>
<li><a href="http://courses.missouristate.edu/KenVollmar/mars/Help/SyscallHelp.html">syscall list (Ken Vollmar @ Missouri State)</a></li>
</ul>
<p>There are many different system services, MARS supports most, if not all of
these. With these things we cna do thing like read from user input and write to the screen. </p>
<ul>
<li><a href="http://courses.missouristate.edu/KenVollmar/mars/download.htm">MARS Download (Ken Vollmar @ Missouri State)</a></li>
</ul>
<p>This is the same link in the previous section, but placed here also for
consistency.</p>
<h2 id="contributing">Contributing</h2>
<p>This tutorial was written in GitHub, and uses a Python markdown module, and
uses a makefile to build it, you can see it and contribute 
<a href="https://github.com/keithstellyes/mips-tutorial">here</a>.</p>
<!-- Part 1 -->

<h1 id="part-1-hello-world">Part 1: Hello, World!</h1>
<h2 id="taking-the-plunge">Taking the plunge</h2>
<p>Let's get our very first Hello, World! program!</p>
<p>This is the only time we'll do it like this, but we'll just look at the
completed source code <em>then</em> examine it.</p>
<pre><code>.data

hello:  .asciiz "Hello, World!\n"

.text
    la $a0, hello
    li $v0, 4
    syscall
    li
    syscall
</code></pre>
<h2 id="explanation-line-by-line">Explanation line-by-line</h2>
<p>We'll need to declare a few places in memory for our data. Well, we only need
one place this time. The lines beginning with . are mainly for the assembler to
organize the parts of the program for us. A part for "variable declarations", a
part for our actual code, etc.   <code>.data</code> is for where we will pre-define
different variables in memory.</p>
<pre><code>.data
</code></pre>
<p>Now that we've marked where we're gonna store our data. Here, we declare a 
place in memory for a null-terminated string, <code>"Hello, World!\n"</code> the \n is
the newline character. The <code>hello:</code> is a label for this place in memory.</p>
<pre><code>hello:  .asciiz "Hello, World!\n"
</code></pre>
<p>Let's mark the section where we'll have actual legitimate instructions.</p>
<pre><code>.text
</code></pre>
<p>Let's store our string into a register, we need to load the address of our
string into the<code>$a0</code> register. This is the register that the print service
takes its argument from. The instruction to do this is <code>la</code>. <code>la</code> means
"Load address", this loads the address we labelled hello into <code>$a0</code>.</p>
<pre><code>la $a0, hello
</code></pre>
<p>So now that we have our string in the register, ready to be used as an argument
for the print string service, we need to actually <em>specify</em> this service. A
table with all the different services and their numbers can be found 
<a href="http://courses.missouristate.edu/KenVollmar/mars/Help/SyscallHelp.html">here</a>.
The specific service that is executed is determined by the value in the
register <code>$v0</code>. The print string service is <code>4</code>. We have a specific
instruction that will set an exact value into this register, <code>li</code>, which is
"Load immediate". It is very similar to the instruction above. (In fact, they
can be interchangable in some cases, but it's not recommended to think of them
this way, for readability.) This instruction is when we have a specific value
in our code, usually a literal like below. Effectively, we are doing
<code>$v0 = 4</code>.</p>
<pre><code>li $v0, 4
</code></pre>
<p>Now that we've actually set the instruction, we need to actually use the
<code>syscall</code> instruction to use a system service. It'll check the arguments in
the various registers that the specific service, and execute accordingly. This
service we're using only takes an argument at <code>$a0</code> which shall contain the
address of our string.</p>
<pre><code>syscall
</code></pre>
<p>Now, we've printed "Hello, World!", we could theoretically just stop here. But,
the best practice in software is that we exit with an exit signal 0, exit
success. This will be a system service like last time, just making a call to
exit, marking a succesful run. This is like <code>return 0</code> in C. Most languages
automatically do this for you.</p>
<pre><code>li $v0, 10
</code></pre>
<p>And then now that we've specified our service, we make our system call, and we
are good.</p>
<pre><code>syscall
</code></pre>
<h2 id="source">Source</h2>
<p>Here's the source code with comments.</p>
<pre><code>.data

hello:  .asciiz "Hello, World!\n"

.text

    la $a0, hello  #argument to print str
    li $v0, 4      #print syscall
    syscall        #make syscall
    li $v0, 10     #exit syscall
    syscall        #tell OS to do the syscall
</code></pre>
<h2 id="wrap-up">Wrap-up</h2>
<p><code>li</code> means "Load immediate" and <code>la</code> means "Load address". <code>li</code> is for
when we have a specific number, a literal as it is called in other languages,
to put into the spot in memory. Whereas <code>la</code> will load an address into it.</p>
<p>A typical program will declare a few spots in memory for variables pre-hand in
the <code>.data</code> section, and the actual instructions proper in <code>.text</code>.</p>
<p>Most I/O will be done with syscalls that take their arguments in specific
registers like <code>$a0</code>.</p>
<!-- Part 2 -->

<h1 id="part-2-ab">Part 2: A+B</h1>
<p>This will be a simple enough program. Get two integers, then print their sum.</p>
<h2 id="walking-through-it">Walking through it.</h2>
<p>First, we declare a spot in memory to store our integers, and for our 
strings to display when we want user input. <code>.word</code> refers to the amount of
data we can address at a time, this is the size of a spot in memory like a
register. This is a bit more of a complicated thing that I'm letting on, but
this is "good enough" for our purposes here. It is a 32 bit integer. 4 bytes.
Neat. And after that data declaration, we'll output to user telling them to
give us an integer.</p>
<pre><code>.data
    a:.word 0
    b:.word 0
    givea: .asciiz "A:"
    giveb: .asciiz "B:"

.text
    la $a0, givea #Load string
    li $v0, 4     #Set syscall to print string
    syscall
</code></pre>
<p>Let's read an integer from the user. To do that, we'll be doing another syscall
specifically, 5, and the result is returned in <code>$v0</code>.</p>
<pre><code>li $v0, 5    #read integer service. Integer returned in $v0
syscall
</code></pre>
<p>Let's go ahead and store the result into memory. Generally speaking, storing
data into registers is risky. This is because external function calls and
system services do not make the guarantee that registers will be preserved
after its call. In MARS MIPS, this isn't necessary. So, for demonstration
purposes, we'll just store it in the register. We'll be using the
instruction <code>sw</code> that stores the <code>word</code> in the first argument, which is a
register, into the second argument, a place in memory.</p>
<pre><code>sw $v0, a
</code></pre>
<p>Let's do the same process, but for <code>b</code>...</p>
<pre><code>la $a0, giveb
li $v0, 4
syscall

li $v0, 5
syscall
sw $v0, b
</code></pre>
<p>Our words are stored in memory, we have both of them, so let's put them into
our registers so we can use them in a math operation. The first loads the value
at <code>a</code> into <code>$a0</code>, the second loading the value at <code>b</code> into <code>$a1</code>.</p>
<pre><code>lw $a0, a
lw $a1, b
</code></pre>
<p>So, we have both of our integers (<em>words</em>) in our registers. If you remember,
I said that we can only do math on the values currently in the registers. 
The <code>add</code> instruction stores the results of the last 2 arguments,
into the first. For <code>add x y z</code>, <code>x</code> will store the results of <code>y + z</code>.</p>
<pre><code>add $a0, $a0, $a1
</code></pre>
<p>And now that we have our math, we'll be using the print integer service, which
is syscall #1. It prints the current integer stored at <code>$a0</code> which we
cleverly already stored the results in from the last operation. This is is
where I find assembly programming to be most enjoyable, slight little
improvements in your code like that.</p>
<pre><code>li $v0, 1 
syscall
</code></pre>
<p>And then, for the farewell, the good old <code>syscall</code> saying we've had no
issues and time to exit.</p>
<pre><code>li $v0, 10
syscall
</code></pre>
<h2 id="source_1">Source</h2>
<pre><code>.data
    a:.word 0
    b:.word 0
    givea: .asciiz "A:"
    giveb: .asciiz "B:"

.text
    # Read integer a
    la $a0, givea #Load string
    li $v0, 4     #Set syscall to print string
    syscall

    li $v0, 5    #read integer service. Integer returned in $v0
    syscall
    sw $v0, a    #store our integer into the memory location a.

    # Read integer b
    la $a0, giveb
    li $v0, 4
    syscall

    li $v0, 5   #read integer service.
    syscall
    sw $v0, b   #store our integer into the memory location b.

    lw $a0, a
    lw $a1, b

    add $a0, $a0, $a1 #arg0 = arg1+arg2

    li $v0, 1 #print integer service, it prints the integer stored at register $a0
    syscall

    #exit   
    li $v0, 10
    syscall
</code></pre>
<h2 id="wrap-up_1">Wrap-up</h2>
<p>Often-times we need to get used to moving data around by storing them in
memory with instructions like <code>sw</code> and math instructions will store
a register with the sum of two registers.</p>
<!-- Part 3 -->

<h1 id="part-3-echo">Part 3: Echo</h1>
<p>Get input from user, then repeat it.
This program will demonstrate allocation of memory and storing strings.</p>
<h2 id="walking-through-it_1">Walking through it.</h2>
<p>This time, we won't bother declaring in variables using <code>.data</code>, and just go
straight to the instructions in <code>.text</code></p>
<pre><code>.text
</code></pre>
<p>Before we can take a string input, we need to make sure there is a place for it
in memory. That is to say, we will be <em>allocating</em>. We'll be doing something
akin to <code>malloc</code> in C or C++. We'll be using the sbrk system service. It'll
declare a number of bytes and returns its address so that we can store and use
variables in that spot. It will store <code>$a0</code> number of bytes, and returns its
address in <code>$v0</code>.</p>
<pre><code>li $a0, 400
li $v0, 9
syscall
</code></pre>
<p>Next, we'll be using the read string service. It'll store at the address stored
in <code>$a0</code> and it will only read up to a specific number of bytes, <code>$a1</code>
number of bytes. We need to make sure it doesn't read more bytes than we know
are allocated, otherwise we'll overflow and write to memory we shouldn't be.
Now, so the first step is to move the address of the data we allocated to
<code>$a0</code> so our read string instruction will read to it. To move from register
to register with <code>la</code>, we need to use a () syntax. This is because
frequently, there'll be an offset from that. For now though, we don't have to
worry about that.</p>
<pre><code>la $a0, ($v0)
</code></pre>
<p>Okay, and now let's set the limit on the number of bytes we will read...</p>
<pre><code>li $a1, 400
</code></pre>
<p>Now, if you remember, our memory allocation service only takes two arguments,
in <code>$a0</code> and in <code>$a1</code>, abd we've already loaded our address in <code>$a0</code> and
the limit on bytes to read in <code>$a1</code>, so now let's make the call.</p>
<pre><code>syscall
</code></pre>
<p>Now generally, we would have copied the address into memory using <code>sw</code>, and
in other architectures/other implementations, that address would have been lost
if we didn't make a copy elsewhere before we made that last call. MARS is more
forgiving, however. So, the location of our string is still stored at <code>$a0</code>.
And if you remember, our print string argument reads the string at the address
stored at... <code>$a0</code>... So our print string argument is already set, we just
need to specify the service.</p>
<pre><code>li $v0, 4
</code></pre>
<p>And then, print that string.</p>
<pre><code>syscall
</code></pre>
<p>And then like always, we need to exit our program, so let's do that.</p>
<pre><code>li $v0, 10
syscall
</code></pre>
<h2 id="source_2">Source</h2>
<pre><code>.text
    li $a0, 500   #allocate 400 bytes
    li $v0, 9     #set syscall to allocate memory
    syscall

    la $a0,($v0) #set the target address for the read string 
    li $a1, 500   #set max number of chars to read 
    li $v0, 8     #set syscall to read string
    syscall

    li $v0,4     #set syscall to print string
    syscall

    li $v0,10    #exit cleanly with EXIT_SUCCESS
    syscall
</code></pre>
<h2 id="wrap-up_2">Wrap-up</h2>
<p>To allocate a large amount of data, we have to allocate it by using a system
service, and then it will give us the location of where it allocated the
memory where we will then print it.</p>
<!-- Part 4 -->

<h1 id="part-4-a-b">Part 4: A == B</h1>
<p>Get two integers from the user, state if they're equal or not.</p>
<h2 id="walking-through-it_2">Walking through it</h2>
<p>So, if you've done the Part 2, A+B, then the beginning of this part should
look pretty familiar. First, let's declare spots in memory for our data.</p>
<pre><code>.data
    a:      .word 0
    b:      .word 0
    givea:  .asciiz "Integer A:"
    giveb:  .asciiz "Integer B:"
    neqstr: .asciiz "Integers not equal.\n"
    eqstr:  .asciiz "Integers are equal.\n"
</code></pre>
<p>Let's read our first integer A, this is pretty much copy-pasted from Part 2.</p>
<pre><code>.text
    # Read integer a
    la $a0, givea
    li $v0, 4
    syscall
    li $v0, 5
    syscall
    sw $v0, a
</code></pre>
<p>Let's get the second integer B, this one is going to be slightly different from
last time.</p>
<pre><code>la $a0, giveb
li $v0, 4
syscall

li $v0, 5   #read integer service.
syscall
</code></pre>
<p>Our integer B is in <code>$v0</code>, last time we stored it in memory. This time we
wont'. But we still need to do our comparison operation, and have to do it on
our registers, so let's load A.</p>
<pre><code>lw $a0, a
</code></pre>
<p>And now, we need to compare the values. At the low-level, we need to use
<em>branching</em>. To do branching, we will make a comparison, and then depending
on that result, either: Jump to a specified label or: nothing. In this case,
we will use <code>beq</code>, given two arguments, it will jump to a label if its two
register arguments are equal. Otherwise, nothing happens. Let's call this label
<code>equals</code>.</p>
<pre><code>beq $a0, $v0, equals
</code></pre>
<p>We haven't actually made our <code>equals</code> label yet, between the <code>equals</code> label
and that last line, we need to put our code we want to execute, that is, the if
they're not equal. Since both equals and not equals cases will print, we don't
need to put it in our not equals section, so all we need to do between our
<code>equals</code> section and right here, is to load the string and jump to our
procedure for print and exit. We have the <code>j</code> instruction that will always
go to a specific label.</p>
<pre><code>la $a0, neqstr
j printandexit
</code></pre>
<p>Okay, now, we have our not equals, so let's make our equals section. We'll
first need a label. You'll notice this is the same syntax as when we mark spots
in memory for our data, this is no coincidence, since instructions are in
memory just like our data.</p>
<pre><code>equals:
</code></pre>
<p>And then, let's do our similar procedure for equals.</p>
<pre><code>la $a0, eqstr
j printandexit
</code></pre>
<p>Let's make our final procedure, printandexit. We will print whatever string is
in <code>$a0</code>, which we would've already dealt with loading.</p>
<pre><code>printandexit:
    li $v0, 4
    syscall
    li $v0, 10
    syscall
</code></pre>
<h2 id="source_3">Source</h2>
<pre><code>.data
    a:      .word 0
    b:      .word 0
    givea:  .asciiz "Integer A:"
    giveb:  .asciiz "Integer B:"
    neqstr: .asciiz "Integers not equal.\n"
    eqstr:  .asciiz "Integers are equal.\n"

.text
    # Read integer a
    la $a0, givea #Load string
    li $v0, 4     #Set syscall to print string
    syscall

    li $v0, 5    #read integer service. Integer returned in $v0
    syscall
    sw $v0, a    #store our integer into the memory location a.

    # Read integer b
    la $a0, giveb
    li $v0, 4
    syscall

    li $v0, 5   #read integer service.
    syscall

    lw $a0, a
    beq $a0, $v0, equals # if not equals, then it just goes to next line.

    la $a0, neqstr #If we get here, then A != B
    j printandexit #without this jump, we would also execute the equals procedure
equals: #Sets the string-to-print as the output for A==B
    la $a0, eqstr
    j printandexit #We could delete this and "fall through"

printandexit: # Prints whatever is in $a0 then exits.
    li $v0, 4
    syscall
    li $v0, 10
    syscall
</code></pre>
<h2 id="wrap-up_3">Wrap-up</h2>
<p>Branching and jump instructions are fundamental to only conditionally executing
code. Now, there is a special type of branching instruction that will let us
have true procedures, those that can have recursion, but here it's not
necessary. Forgetting jump or branch instructions before your sections can lead
to code blocks you don't want executing. Be careful.</p>
<p>A list of MIPS instructions, including all the different branching
instructions can be found 
<a href="http://www.mrc.uidaho.edu/mrc/people/jff/digital/MIPSir.html">here.</a></p>
<!-- Part 5 -->

<h1 id="part-5-loop-n-times">Part 5: Loop N Times</h1>
<p>This time, we will write a simple program, that when given an integer, it will
print that many times, each time doing a "countdown". We can easily combine
the conditional branching we used in Part 4 here, but with a bit of modification.</p>
<h2 id="walking-through-it_3">Walking through it</h2>
<p>Our <code>.data</code> this time isn't going to be super interesting. Let's just have 3
different strings: One for when we ask for input, one to say that we're done,
and one that is just a newline character. This is desirable because the service
to print an integer does not automatically append a newline.</p>
<pre><code>.data
    newline: .asciiz "\n"
    inputstr: .asciiz "How many times to loop?\n"
    donestr: .asciiz "No more times to loop :'(\n"
</code></pre>
<p>Let's ask for an integer, and store it. We've done this a lot already.</p>
<pre><code>.text 
    la $a0, inputstr #Load string
    li $v0, 4     #Set syscall to print string
    syscall

    li $v0, 5    #read integer service. Integer returned in $v0
    syscall
</code></pre>
<p>Here's where we diverge. Both the print string and print integer services take
their argument in <code>$a0</code>, so we will have to find a safe place for our
integer. This time, we'll just store it in a register that won't get modified.
This specific implementation and set-up we can treat a register as a safe place
for holding data, but in many architectures and systems, calling a system
service or C function makes no guarantees about preserving your registers. So
don't make that mistake like I did when you go to other assembly architectures.
We will use the <code>$v1</code> register, if for no reason other than to be arbitrary.
Again, holding data in registers between system calls is discouraged at best,
and simply won't work or break things at worst. But here, it'll let us focus
on other core assembly concepts. We will use the <code>move</code> instruction to do
this.</p>
<pre><code>move $v1, $v0
</code></pre>
<p>So now, let's begin the loop. Since we know we need a conditional at the start
and to jump back, we will need a label and our conditional. We will call our
post-loop code, <code>alldone</code>. The condition will branch when our integer hits 0.</p>
<pre><code>loop:   
    beqz $v1, alldone
</code></pre>
<p>Okay, now that we have implemented our condition, let's print our integer. The
print integer service is 1, and takes the argument in <code>$a0</code>. It does not
do a newline after, which is important to remember if we want clean output. We
will have to set the system call, copy from our <code>$v1</code> register storing our
counter, to the <code>$a0</code> to be used as an argument. We use the <code>move</code>
instruction for this. Finally, we make our syscall.</p>
<pre><code>li $v0, 1
move $a0, $v1
syscall
</code></pre>
<p>As previously stated, we still have to print our newline to ensure clean
output, so let's do that. We're just printing it as a string, nothing special.</p>
<pre><code>la $a0, newline
li $v0, 4
syscall
</code></pre>
<p>Now that we've printed our counter, let's decrement it. Many architectures
(such as x86-64, found in most personal computers) have a <code>dec</code> instruction
for just this, lowering it by 1. Here, we do not, we must subtract it by 1.</p>
<pre><code>subi $v1, $v1, 1
</code></pre>
<p>And then, we jump back to the beginning of the loop.</p>
<pre><code>j loop
</code></pre>
<p>Now that our loop is finished, we can write the final <code>alldone</code> segment.
This is just printing the <code>donestr</code> string and exiting. Very boilerplate.
We'll also need to set it to the <code>alldone</code> label.</p>
<pre><code>alldone:
    la $a0, donestr
    li $v0, 4
    syscall
    li $v0, 10
    syscall
</code></pre>
<h2 id="source_4">Source</h2>
<p>Note that I've done a bit of additional indentation for readability.</p>
<pre><code>.data
    newline: .asciiz "\n"
    inputstr: .asciiz "How many times to loop?\n"
    donestr: .asciiz "No more times to loop :'(\n"

.text 
    la $a0, inputstr #Load string
    li $v0, 4     #Set syscall to print string
    syscall

    li $v0, 5    #read integer service. Integer returned in $v0
    syscall

    move $v1, $v0

loop:   
    # If $v1 == 0: goto alldone
    beqz $v1, alldone
        #inside loop...
        #print our counter
        li $v0, 1
        move $a0, $v1
        syscall

        #break to next line
        la $a0, newline
        li $v0, 4
        syscall

        #decrement counter and go back to start of loop.
        subi $v1, $v1, 1
    j loop

alldone:
    #print concluding string, and exit.
    la $a0, donestr
    li $v0, 4
    syscall
    li $v0, 10
    syscall
</code></pre>
<h2 id="wrap-up_4">Wrap-up</h2>
<p>Using a branch and an unconditional jump at both the beginning and end of a
segment of code, we can implement looping structures as we see in normal
programming languages.</p>
<!-- Part 6 -->

<h1 id="part-6-99-bottles-of-beer">Part 6: 99 Bottles of Beer</h1>
<p>We will write a program that counts down, generating the lyrics for the song,
<em>99 Bottles of Beer on the Wall</em> (lyrics 
<a href="http://www.99-bottles-of-beer.net/lyrics.html">here</a>)
No new real new concepts, just a bit of practice.</p>
<h2 id="walking-through-it_4">Walking through it</h2>
<p>First let's declare our strings we call for 3 &lt;= n &lt;= 99.</p>
<pre><code>.data 
    lyrica: .asciiz " bottles of beer on the wall, "
    lyricb: .asciiz " bottles of beer.\nTake one down and pass it around, "
    lyricc: .asciiz " bottles of beer on the wall.\n\n"
</code></pre>
<p>Now, we also have to remember, when 3 &gt; n, that the printing behavior is
not the same. For 3 &gt; n, I'm just going to do a string constant, if you want
it to actually be printing the integer for even the last part, consider it
your challenge. Here, I split them into multiple variables for readability,
but if you want just one super long line, go ahead.</p>
<pre><code>concl1: .asciiz "2 bottles of beer on the wall, 2 bottles of beer.\n"
concl2: .asciiz "Take one down and pass it around, 1 bottle of beer on the wall.\n\n"
concl3: .asciiz "1 bottle of beer on the wall, 1 bottle of beer.\n"
concl4: .asciiz "Take one down and pass it around, no more bottles of beer on the wall.\n\n"
concl5: .asciiz "No more bottles of beer on the wall, no more bottles of beer.\n"
concl6: .asciiz "Go to the store and buy some more, 99 bottles of beer on the wall."
</code></pre>
<p>Now, let's initalize our counter. I'm just going to store it in the register
<code>$a1</code>, as I've stated already, this isn't best practice.</p>
<pre><code>.text
    li $a1, 99
</code></pre>
<p>Now, we're just going to do a loop for this. Where do you think the loop
should terminate? If you remember, the standard behavior ends when n is less
than 3. So, let's terminate when n == 2. Of course, don't forget the label to
jump back to. Let's just call the final block of code printing the final string
and exiting, <code>concl</code>.</p>
<pre><code>loop:
    beq $a1, 2, concl
</code></pre>
<p>If you remember how our print integer works, it prints only the number, no
whitespace or anything. So first, we must move our counter to <code>$a0</code> and 
use the print integer service.</p>
<pre><code>move $a0, $a1
li $v0, 1
syscall
</code></pre>
<p>And then, we will print the first part of the lyric.</p>
<pre><code>la $a0, lyrica
li $v0, 4
syscall
</code></pre>
<p>And then, if you reference the lyrics, you'll realize after here, we print our
counter again, so let's do just that.</p>
<pre><code>move $a0, $a1
li $v0, 1
syscall
</code></pre>
<p>And then we print the second part of the lyrics, using <code>lyricb</code>...</p>
<pre><code>la $a0, lyricb
li $v0, 4
syscall
</code></pre>
<p>Okay, now we get back to the fun part. So now, if you look at the lyrics,
you should notice here, the counter decrements. Well, we already know how to
do that, right? So let's do just that.</p>
<pre><code>subi $a1, $a1, 1
</code></pre>
<p>Cool, and then we print our integer, and the last part of the lyric.</p>
<pre><code>move $a0, $a1
li $v0, 1
syscall
la $a0, lyricc
li $v0, 4
syscall
</code></pre>
<p>And now that the loop is done, we need to add our final jump.</p>
<pre><code>j loop
</code></pre>
<p>Now, we will do our conclusion. We're just printing a series of strings.
Nothing much. Of course, we still need our label, <code>concl</code>. After, we will
exit.</p>
<pre><code>concl:
    la $a0, concl1
    li $v0, 4
    syscall
    la $a0, concl2
    syscall
    la $a0, concl3
    syscall
    la $a0, concl4
    syscall
    la $a0, concl5
    syscall
    la $a0, concl6
    syscall

    li $v0, 10
    syscall
</code></pre>
<h2 id="source_5">Source</h2>
<pre><code>.data 
    lyrica: .asciiz " bottles of beer on the wall, "
    lyricb: .asciiz " bottles of beer.\nTake one down and pass it around, "
    lyricc: .asciiz " bottles of beer on the wall.\n\n"

    concl1: .asciiz "2 bottles of beer on the wall, 2 bottles of beer.\n"
    concl2: .asciiz "Take one down and pass it around, 1 bottle of beer on the wall.\n\n"
    concl3: .asciiz "1 bottle of beer on the wall, 1 bottle of beer.\n"
    concl4: .asciiz "Take one down and pass it around, no more bottles of beer on the wall.\n\n"
    concl5: .asciiz "No more bottles of beer on the wall, no more bottles of beer.\n"
    concl6: .asciiz "Go to the store and buy some more, 99 bottles of beer on the wall."

.text
    li $a1, 99
    # loop for 99 -&gt; 3
loop:
    beq $a1, 2, concl #condition
    move $a0, $a1     #copy counter for use in printing
    li $v0, 1
    syscall

    la $a0, lyrica    #next part of the lyrics to print
    li $v0, 4
    syscall
    move $a0, $a1     #print counter again...
    li $v0, 1
    syscall

    la $a0, lyricb    #next part of the lyrics to print
    li $v0, 4
    syscall

    subi $a1, $a1, 1  #decrement counter and print
    move $a0, $a1
    li $v0, 1
    syscall
    la $a0, lyricc    #print final part
    li $v0, 4
    syscall
    j loop

concl:
    #Printing final string.
    la $a0, concl1
    li $v0, 4
    syscall
    la $a0, concl2
    syscall
    la $a0, concl3
    syscall
    la $a0, concl4
    syscall
    la $a0, concl5
    syscall
    la $a0, concl6
    syscall

    li $v0, 10
    syscall
</code></pre>
<h2 id="wrap-up_5">Wrap-up</h2>
<p>Not much to say in the wrap-up this time. Remember to experiment with
different instructions to get comfortable with MIPS.</p>
<!-- Part 7 -->

<h1 id="part-7-guess-the-number">Part 7: Guess the Number</h1>
<p>We will write a program that will randomly generate a number <code>n</code> and then
repeatedly ask for integer input until the input is equal to <code>n</code>. The program
will also state if <code>n</code> is greater than or less than the integer input.</p>
<h2 id="walking-through-it_5">Walking through it</h2>
<p>This time, we will not store our number in a register, but instead in a
place in memory, as is ideal. All random generators have an <em>id</em>, don't 
forget.
First, let's declare our initial data...</p>
<pre><code>.data
    toosmallstr:  .asciiz "n is greater than input.\n"
    toobigstr:    .asciiz "n is lesser than input.\n"
    correctstr:   .asciiz "n is equal to input.\n"
    makeguessstr:.asciiz "Make a guess:"
    n:         .word   0
    randgenid: .word   1
</code></pre>
<p>We will be using a <code>syscall</code> that will generate a pseudorandom number. If we
go back to the<code>syscall</code> chart
<a href="http://courses.missouristate.edu/KenVollmar/mars/Help/SyscallHelp.html">here</a>
we see that we have <code>syscall 42</code>. This generates a random number
0 &lt;= n &lt; [upperbound]
It requires us to set a <em>seed</em>. Typically, a pseudorandom number generator will
use the system time for this. For this, we have <code>syscall 30</code>. So first, let's
get the time to use for our seed.</p>
<pre><code>.text
    li $v0, 30
    syscall
</code></pre>
<p>We have the time stored. Look at the table, you'll see we 
have both
low-order time in <code>$a0</code> and high-order in <code>$a1</code>. For our purposes, we will
use high-order time for our purposes. Before we can use our random number
generator, we must first set the seed. The number we are going to use as our
seed is in <code>$a1</code> <code>syscall 40</code> is there to set the seed of our random number
generator, so let's move our desired seed in <code>$a0</code> into <code>$a1</code> and then make
the <code>syscall 40</code> to set the low-order time as our seed. Also, we need to make
sure we are using the correct random generator id, so let's set that too.</p>
<pre><code>move $a1, $a0
lw $a0, randgenid
li $v0,40
syscall
</code></pre>
<p>Now that our random number generator is ready, we can actually use the
generator. It sets its upper bound in <code>$a1</code>, now if you remember, it will
generate a number in the range of 0 - (<code>$a1</code> - 1) so we can set the upper
bound to 10, and then increment to get a number in the range of 1-10.</p>
<pre><code>li $a1,10
li $v0,42
syscall
</code></pre>
<p>We now have our random number generated, but it is 1 less than it should be.
Also, it still needs to be stored in the memory location <code>n</code>. So let's 
add 1 to it, then store
it.</p>
<pre><code>add $a0, $a0, 1
sw $a0, n
</code></pre>
<p>Our number is stored and ready, so now we can start our loop. First, we will
need to get a value. We'll do this every iteration of the loop, so let's have
the label, too.</p>
<pre><code>loop:
    la $a0, makeguessstr
    li $v0, 4
    syscall
    li $v0, 5
    syscall
</code></pre>
<p>We have our integer in <code>v0</code>, so let's see if they were correct. Our
generated number is stored in <code>n</code>, so we have to get that before we make
our comparison. We'll call our final code called when user correctly guesses
the number, <code>done</code>.</p>
<pre><code>lw $a0, n
beq $a0, $v0, done
</code></pre>
<p>We have our branch for a correct guess, let's do the branch for if the user
inputs a number greater than the generated number <code>n</code>.</p>
<pre><code>blt $a0, $v0, toobig
</code></pre>
<p>And of course, we need the final condition for if the user's number is too
small. We've already tested for too great, and equal, so if this part of the
instructions is reached, then we don't have to do a comparison to know 
the input
is too small, so we can use a simple jump.</p>
<pre><code>j toosmall
</code></pre>
<p>Let's write those referenced sections of code. Let's write the 
<code>toobig</code>
section. It just needs to print out the number was too big, and then go back
to the beginning of the loop.</p>
<pre><code>toobig:
    la $a0, toobigstr
    li $v0, 4
    syscall
    j loop
</code></pre>
<p>Same thing again, but for the number <code>n</code> being too small.</p>
<pre><code>toosmall:
    la $a0, toosmallstr
    li $v0, 4
    syscall
    j loop
</code></pre>
<p>And then, our <code>done</code> section is just printing out a string and exiting.
Simple.</p>
<pre><code>done:
    la $a0, correctstr
    li $v0, 4
    syscall
    li $v0, 10
    syscall
</code></pre>
<h2 id="source_6">Source</h2>
<pre><code>.data
    toosmallstr: .asciiz "n is greater than input.\n"
    toobigstr:   .asciiz "n is lesser than input.\n"
    correctstr:  .asciiz "n is equal to input.\n"
    makeguessstr:.asciiz "Make a guess:"
    n:        .word 0
    randgenid:.word 1

.text
    #get system time
    li $v0, 30
    syscall

    #use system time for seed
    move $a1, $a0
    lw   $a0, randgenid
    li $v0,40
    syscall

    li $a1,10
    li $v0,42
    syscall
    #our number is 1 less than it should be. Adjust.
    add $a0, $a0, 1
    sw $a0, n

loop:
    #print the make guess string and get integer.
    la $a0, makeguessstr
    li $v0, 4
    syscall
    li $v0, 5
    syscall

    #store our integer.
    lw $a0, n
    #n == input?
    beq $a0, $v0, done
    #n &lt; input?
    blt $a0, $v0, toobig
    #n &gt; input.
    j toosmall

toobig:
    la $a0, toobigstr
    li $v0, 4
    syscall
    j loop

toosmall:
    la $a0, toosmallstr
    li $v0, 4
    syscall
    j loop

done:
    la $a0, correctstr
    li $v0, 4
    syscall
    li $v0, 10
    syscall
</code></pre>
<h2 id="wrap-up_6">Wrap-up</h2>
<p>Making extensive use of sub-procedures as used here can be quite useful as
your code increases in complexity.</p>
<!-- Part 8 -->

<h1 id="part-8-getting-string-length">Part 8: Getting String Length</h1>
<p>We will write a program that demonstrates getting the length of a string.</p>
<h2 id="walking-through-it_6">Walking through it</h2>
<p>Strings here are an array of characters, with a final character, the null
character, with the underlying number of "0", it is also known as the null
terminator. These strings are known as <em>null-terminated strings</em>.</p>
<p>First, let's declare our variables...</p>
<pre><code>.data 
    string: .asciiz "Beware of bugs in the above code; I have only proved it correct, not tried it - Donald Knuth"
    thelengthisa: .asciiz "The length of the string,'"
    thelengthisb: .asciiz "' is "
    thelengthisc: .asciiz " characters.\n"
</code></pre>
<p>And then, let's do our printing:</p>
<pre><code>.text
    la $a0, thelengthisa
    li $v0, 4
    syscall
    la $a0, string
    syscall
    la $a0, thelengthisb
    syscall
</code></pre>
<p>Okay, now it is time to start the logic we're intererested in. First of all,
we must load the address of the string we want to get the length of. We will
store the address in <code>$a1</code>. Remember, an address is just another number, one
that we can increment. What is called the address of a string is really just
the address of the inital character. The second character is that address + 1.
The very last character is followed by the null terminator with ASCII value of
0. So, let's clear <code>$a0</code>, and load that address.</p>
<pre><code>la $a1, string
li $a0, 0
</code></pre>
<p>And now that we have initalized everything, it is time for the loop. Basically,
we will have a loop checking every character in the string, and when the
character is not the null terminator, we increment the counter. When it is the
null terminator, we will exit the loop. For the first part of the loop, we must
load the character at the address. We will use <code>lb</code>, meaning load byte. The
( ) notation on the second argument means it will take the value at <code>$a2</code>,
then go to that address in memory. Basically, it asssumes <code>$a2</code> has a pointer
to the value we <em>really</em> want. In this case, the character.</p>
<pre><code>loop:
    lb $a2, ($a1)
</code></pre>
<p>Now that we've loaded the character, let's increment our pointer.</p>
<pre><code>addi $a1, $a1, 1
</code></pre>
<p>Now, let's see if that last character was a null terminator, if so, exit the
loop.</p>
<pre><code>beqz $a2, exit
</code></pre>
<p>Else, let's increment the counter, then go back to the head of the loop.</p>
<pre><code>addi $a0, $a0, 1
j loop
</code></pre>
<p>And finally, we'll write our exit code. We print out our counter, the final
string, then make the exit <code>syscall</code>.</p>
<pre><code>exit:
    li $v0, 1
    syscall
    li $v0, 4
    la $a0, thelengthisc
    syscall
</code></pre>
<h2 id="source_7">Source</h2>
<pre><code>.data 
    string: .asciiz "Beware of bugs in the above code; I have only proved it correct, not tried it - Donald Knuth"
    thelengthisa: .asciiz "The length of the string,'"
    thelengthisb: .asciiz "' is "
    thelengthisc: .asciiz " characters.\n"
.text
    #print inital...
    la $a0, thelengthisa
    li $v0, 4
    syscall
    la $a0, string
    syscall
    la $a0, thelengthisb
    syscall

    # load a pointer to the string.
    la $a1, string
    li $a0, 0
loop:
    # get the character at pointer
    lb $a2, ($a1)
    # increment pointer
    addi $a1, $a1, 1
    # test for character at pointer being null terminator. If so, exit loop.
    beqz $a2, exit
    # increment counter
    addi $a0, $a0, 1
    # return to head of loop.
    j loop

exit:
    # print count
    li $v0, 1
    syscall
    # print final strings, exit syscall.
    li $v0, 4
    la $a0, thelengthisc
    syscall
</code></pre>
<h2 id="wrap-up_7">Wrap-up</h2>
<p>To do various operations on strings/lists/arrays/similar data structures, it
is imperative to use pointer arithmetic as we did in this example. </p>
<!-- footer -->

<h1 id="licensingrightscontact">Licensing/Rights/Contact</h1>
<p>For questions, comments, corrections, inquiries, etc. I may be reached at
contact@keithstellyes.com</p>
<p>The content of this tutorial is under a Creative Commons
Attribution 4.0 International License.</p>
<p><a href="https://creativecommons.org/licenses/by/4.0/legalcode">Click here for the license</a></p>
<p><a href="https://wiki.creativecommons.org/wiki/best_practices_for_attribution">For best practices regarding attribution, look here</a></p>